/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
import { __awaiter, __decorate, __param } from "tslib";
import { Subject, from, throwError } from 'rxjs';
import { map, mergeMap, switchMap, catchError } from 'rxjs/operators';
import { Router } from '@angular/router';
import { JwksValidationHandler, OAuthService } from 'angular-oauth2-oidc';
import { LocalStorageService } from './local-storage.service';
import { ConfigurationService } from './configuration.service';
import { DbKeys } from '../helpers/db-keys';
import { JwtHelper } from '../helpers/jwt-helper';
import { Utilities } from '../helpers/utilities';
import { AuthStorageService } from './auth-storage.service';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { AlertService, MessageSeverity } from './alert.service';
export const API_BASE_URL = new InjectionToken('API_BASE_URL');
let AuthEndpointService = class AuthEndpointService {
    constructor(router, oAuthService, configService, storageService, alertService) {
        this.router = router;
        this.oAuthService = oAuthService;
        this.configService = configService;
        this.storageService = storageService;
        this.alertService = alertService;
        this._previousIsLoggedInCheck = false;
        this._loginStatus = new Subject();
        this.initializeLoginStatus();
    }
    get webBaseUrl() { return this.configService.webBaseUrl; }
    get loginUrl() { return this.configService.loginUrl; }
    get homeUrl() { return this.configService.homeUrl; }
    get apiBaseUrl() { return this.configService.apiBaseUrl + '/v' + this.apiVersion; }
    get apiVersion() { return this.configService.apiVersion; }
    get authConfig() { return this.configService.authConfig; }
    get authProvider() { return this.configService.authProvider; }
    set authProvider(value) { this.configService.authProvider = value; }
    initializeLoginStatus() {
        this.storageService.getInitEvent().subscribe(() => {
            this.reevaluateLoginStatus();
        });
    }
    gotoPage(page, preserveParams = true) {
        const navigationExtras = {
            queryParamsHandling: preserveParams ? 'merge' : '', preserveFragment: preserveParams
        };
        this.router.navigate([page], navigationExtras);
    }
    gotoHomePage() {
        this.router.navigate([this.homeUrl]);
    }
    redirectLoginUser() {
        const redirect = this.loginRedirectUrl && this.loginRedirectUrl != '/' && this.loginRedirectUrl != ConfigurationService.defaultHomeUrl ? this.loginRedirectUrl : this.homeUrl;
        this.loginRedirectUrl = null;
        const urlParamsAndFragment = Utilities.splitInTwo(redirect, '#');
        const urlAndParams = Utilities.splitInTwo(urlParamsAndFragment.firstPart, '?');
        const navigationExtras = {
            fragment: urlParamsAndFragment.secondPart,
            queryParams: Utilities.getQueryParamsFromString(urlAndParams.secondPart),
            queryParamsHandling: 'merge'
        };
        this.router.navigate([urlAndParams.firstPart], navigationExtras);
    }
    redirectLogoutUser() {
        const redirect = this.logoutRedirectUrl ? this.logoutRedirectUrl : this.loginUrl;
        this.logoutRedirectUrl = null;
        this.router.navigate([redirect]);
    }
    redirectForLogin() {
        this.loginRedirectUrl = this.router.url;
        this.router.navigate([this.loginUrl]);
    }
    reLogin() {
        if (this.reLoginDelegate)
            this.reLoginDelegate();
        else
            this.redirectForLogin();
    }
    refreshLogin() {
        if (this.oAuthService.discoveryDocumentLoaded) {
            return from(this.refreshLoginAuthProvider()).pipe(map(() => this.processLoginResponse(this.oAuthService.getAccessToken(), this.rememberMe)));
        }
        else {
            this.configureAuthService();
            return from(this.oAuthService.loadDiscoveryDocument())
                .pipe(mergeMap(() => this.refreshLogin()));
        }
    }
    refreshLoginAuthProvider() {
        if (this.authProvider == 'idsvr')
            return this.oAuthService.refreshToken();
        else
            return this.oAuthService.silentRefresh();
    }
    login(authProvider, userName, password, rememberMe) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isLoggedIn)
                this.logout();
            this.alertService.startLoadingMessage("Attempting login...");
            this.authProvider = authProvider;
            this.configureAuthService();
            AuthStorageService.RememberMe = rememberMe;
            yield this.oAuthService.loadDiscoveryDocument();
            if (this.authProvider == 'idsvr') {
                yield this.oAuthService.fetchTokenUsingPasswordFlow(userName, password);
                this.processLoginResponse(this.oAuthService.getAccessToken(), rememberMe);
            }
            else
                yield this.oAuthService.initImplicitFlow();
        });
    }
    configureAuthService() {
        this.oAuthService.configure(this.authConfig);
        this.oAuthService.tokenValidationHandler = new JwksValidationHandler();
    }
    processImplicitFlowResponse() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.configureAuthService();
                if ((yield this.oAuthService.loadDiscoveryDocumentAndLogin({ disableOAuth2StateCheck: true, preventClearHashAfterLogin: false }))
                    && this.oAuthService.hasValidAccessToken) {
                    this.oAuthService.setupAutomaticSilentRefresh();
                    return this.processLoginResponse(this.oAuthService.getIdToken(), true);
                }
                else {
                    this.alertService.showStickyMessage("Login", "Error logging into Auth Provider", MessageSeverity.error);
                    this.gotoPage("login");
                    return null;
                }
            }
            catch (error) {
                const errorsRequiringUserInteraction = [
                    'interaction_required',
                    'login_required',
                    'account_selection_required',
                    'consent_required',
                ];
                if (error && error.reason && errorsRequiringUserInteraction.indexOf(error.reason.error) >= 0)
                    this.oAuthService.initImplicitFlow();
                else
                    throwError(error);
            }
        });
    }
    processLoginResponse(accessToken, rememberMe) {
        if (accessToken == null)
            throw new Error('accessToken cannot be null');
        const jwtHelper = new JwtHelper();
        const decodedAccessToken = jwtHelper.decodeToken(accessToken);
        const permissions = Array.isArray(decodedAccessToken.permission) ? decodedAccessToken.permission : [decodedAccessToken.permission];
        if (!this.isLoggedIn)
            this.configService.import(decodedAccessToken.configuration);
        const user = new UserViewModel();
        user.id = decodedAccessToken.sub;
        user.userName = decodedAccessToken.name;
        user.fullName = decodedAccessToken.fullname;
        user.email = decodedAccessToken.email;
        user.jobTitle = decodedAccessToken.jobtitle;
        user.phoneNumber = decodedAccessToken.phone_number;
        user.roles = Array.isArray(decodedAccessToken.role) ? decodedAccessToken.role : [decodedAccessToken.role];
        user.isEnabled = true;
        this.saveUserDetails(user, permissions, rememberMe);
        this.reevaluateLoginStatus(user);
        this.alertService.stopLoadingMessage();
        this.gotoHomePage();
        return user;
    }
    saveUserDetails(user, permissions, rememberMe) {
        if (rememberMe) {
            this.storageService.savePermanentData(permissions, DbKeys.USER_PERMISSIONS);
            this.storageService.savePermanentData(user, DbKeys.CURRENT_USER);
        }
        else {
            this.storageService.saveSyncedSessionData(permissions, DbKeys.USER_PERMISSIONS);
            this.storageService.saveSyncedSessionData(user, DbKeys.CURRENT_USER);
        }
        this.storageService.savePermanentData(rememberMe, DbKeys.REMEMBER_ME);
    }
    logout() {
        this.storageService.deleteData(DbKeys.USER_PERMISSIONS);
        this.storageService.deleteData(DbKeys.CURRENT_USER);
        this.configService.clearLocalChanges();
        this.oAuthService.logOut(true);
        this.reevaluateLoginStatus();
    }
    reevaluateLoginStatus(currentUser) {
        const user = currentUser || this.storageService.getDataObject(DbKeys.CURRENT_USER);
        const isLoggedIn = user != null && this.oAuthService.hasValidAccessToken();
        if (this._previousIsLoggedInCheck != isLoggedIn) {
            setTimeout(() => {
                this._loginStatus.next(isLoggedIn);
            });
        }
        this._previousIsLoggedInCheck = isLoggedIn;
    }
    getLoginStatusEvent() {
        return this._loginStatus.asObservable();
    }
    get currentUser() {
        const user = this.storageService.getDataObject(DbKeys.CURRENT_USER);
        this.reevaluateLoginStatus(user);
        return user;
    }
    get userPermissions() {
        return this.storageService.getDataObject(DbKeys.USER_PERMISSIONS) || [];
    }
    get accessToken() {
        return this.authProvider == 'idsvr' ?
            this.oAuthService.getAccessToken() :
            this.oAuthService.getIdToken();
    }
    get accessTokenExpiryDate() {
        return new Date(this.oAuthService.getAccessTokenExpiration());
    }
    get isSessionExpired() {
        if (this.accessTokenExpiryDate == null) {
            return true;
        }
        return this.accessTokenExpiryDate.valueOf() <= new Date().valueOf();
    }
    get refreshToken() {
        return this.oAuthService.getRefreshToken();
    }
    get isLoggedIn() {
        return this.currentUser != null && this.oAuthService.hasValidAccessToken();
    }
    get rememberMe() {
        return this.storageService.getDataObject(DbKeys.REMEMBER_ME) == true;
    }
};
AuthEndpointService = __decorate([
    Injectable(),
    __param(0, Inject(Router)),
    __param(1, Inject(OAuthService)),
    __param(2, Inject(ConfigurationService)),
    __param(3, Inject(LocalStorageService)),
    __param(4, Inject(AlertService))
], AuthEndpointService);
export { AuthEndpointService };
export class BaseEndpointService {
    constructor(configService, authService) {
        this.configService = configService;
        this.authService = authService;
    }
    get apiBaseUrl() { return this.configService.apiBaseUrl + '/v' + this.apiVersion; }
    get apiVersion() { return this.configService.apiVersion; }
    transformOptions(options) {
        options.headers = new HttpHeaders({
            Authorization: 'Bearer ' + this.authService.accessToken,
            'Content-Type': 'application/json',
            Accept: 'application/json, text/plain, */*'
        });
        return Promise.resolve(options);
    }
    transformResult(url, response, processResponse) {
        return from(processResponse(response)).pipe(catchError(error => {
            return this.handleError(error, () => processResponse(response));
        }));
    }
    refreshLogin() {
        return this.authService.refreshLogin().pipe(catchError(error => {
            return this.handleError(error, () => this.refreshLogin());
        }));
    }
    handleError(error, continuation) {
        if (error.status == 401) {
            if (this.isRefreshingLogin) {
                return this.pauseTask(continuation);
            }
            this.isRefreshingLogin = true;
            return from(this.authService.refreshLogin()).pipe(mergeMap(() => {
                this.isRefreshingLogin = false;
                this.resumeTasks(true);
                return continuation();
            }), catchError(refreshLoginError => {
                this.isRefreshingLogin = false;
                this.resumeTasks(false);
                this.authService.reLogin();
                if (refreshLoginError.status == 401 || (refreshLoginError.error && refreshLoginError.error.error == 'invalid_grant')) {
                    return throwError('session expired');
                }
                else {
                    return throwError(refreshLoginError || 'server error');
                }
            }));
        }
        if (error.error && error.error.error == 'invalid_grant') {
            this.authService.reLogin();
            return throwError((error.error && error.error.error_description) ? `session expired (${error.error.error_description})` : 'session expired');
        }
        else {
            return throwError(error);
        }
    }
    pauseTask(continuation) {
        if (!this.taskPauser) {
            this.taskPauser = new Subject();
        }
        return this.taskPauser.pipe(switchMap(continueOp => {
            return continueOp ? continuation() : throwError('session expired');
        }));
    }
    resumeTasks(continueOp) {
        setTimeout(() => {
            if (this.taskPauser) {
                this.taskPauser.next(continueOp);
                this.taskPauser.complete();
                this.taskPauser = null;
            }
        });
    }
}
let AccountEndpointService = class AccountEndpointService extends BaseEndpointService {
    constructor(configService, authService, http, baseUrl) {
        super(configService, authService);
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
    }
    getCurrentUser() {
        let url_ = this.baseUrl + "/Account/users/me";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetCurrentUser(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetCurrentUser(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetCurrentUser(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    updateCurrentUser(user) {
        let url_ = this.baseUrl + "/Account/users/me";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(user);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processUpdateCurrentUser(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdateCurrentUser(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processUpdateCurrentUser(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    updateCurrentUser2(patch) {
        let url_ = this.baseUrl + "/Account/users/me";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processUpdateCurrentUser2(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdateCurrentUser2(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processUpdateCurrentUser2(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getUserById(id) {
        let url_ = this.baseUrl + "/Account/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetUserById(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetUserById(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetUserById(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    updateUser(id, user) {
        let url_ = this.baseUrl + "/Account/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(user);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processUpdateUser(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdateUser(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processUpdateUser(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    updateUser2(id, patch) {
        let url_ = this.baseUrl + "/Account/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processUpdateUser2(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdateUser2(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processUpdateUser2(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteUser(id) {
        let url_ = this.baseUrl + "/Account/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteUser(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteUser(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteUser(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getUserByUserName(userName) {
        let url_ = this.baseUrl + "/Account/users/username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetUserByUserName(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetUserByUserName(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetUserByUserName(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getUsersAll() {
        let url_ = this.baseUrl + "/Account/users";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetUsersAll(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetUsersAll(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetUsersAll(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(UserViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    register(user) {
        let url_ = this.baseUrl + "/Account/users";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(user);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processRegister(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRegister(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processRegister(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = UserViewModel.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getUsers(pageNumber, pageSize) {
        let url_ = this.baseUrl + "/Account/users/{pageNumber}/{pageSize}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetUsers(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetUsers(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetUsers(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(UserViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    unblockUser(id) {
        let url_ = this.baseUrl + "/Account/users/unblock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processUnblockUser(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUnblockUser(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processUnblockUser(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    userPreferences() {
        let url_ = this.baseUrl + "/Account/users/me/preferences";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processUserPreferences(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUserPreferences(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processUserPreferences(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    userPreferences2(data) {
        let url_ = this.baseUrl + "/Account/users/me/preferences";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(data);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processUserPreferences2(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUserPreferences2(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processUserPreferences2(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getRoleById(id) {
        let url_ = this.baseUrl + "/Account/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetRoleById(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetRoleById(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetRoleById(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RoleViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    updateRole(id, role) {
        let url_ = this.baseUrl + "/Account/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(role);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processUpdateRole(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdateRole(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processUpdateRole(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteRole(id) {
        let url_ = this.baseUrl + "/Account/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteRole(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteRole(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteRole(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RoleViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getRoleByName(name) {
        let url_ = this.baseUrl + "/Account/roles/name/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetRoleByName(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetRoleByName(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetRoleByName(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RoleViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result403 = null;
                let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = ProblemDetails.fromJS(resultData403);
                return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getRolesAll() {
        let url_ = this.baseUrl + "/Account/roles";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetRolesAll(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetRolesAll(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetRolesAll(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(RoleViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    createRole(role) {
        let url_ = this.baseUrl + "/Account/roles";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(role);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processCreateRole(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreateRole(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processCreateRole(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = RoleViewModel.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getRoles(pageNumber, pageSize) {
        let url_ = this.baseUrl + "/Account/roles/{pageNumber}/{pageSize}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetRoles(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetRoles(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetRoles(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(RoleViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllPermissions() {
        let url_ = this.baseUrl + "/Account/permissions";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllPermissions(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllPermissions(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllPermissions(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(PermissionViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
};
AccountEndpointService = __decorate([
    Injectable(),
    __param(0, Inject(ConfigurationService)), __param(1, Inject(AuthEndpointService)), __param(2, Inject(HttpClient)), __param(3, Optional()), __param(3, Inject(API_BASE_URL))
], AccountEndpointService);
export { AccountEndpointService };
let EventEndpointService = class EventEndpointService extends BaseEndpointService {
    constructor(configService, authService, http, baseUrl) {
        super(configService, authService);
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
    }
    getAllEvents(includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{includePropertyPaths}";
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEvents(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEvents(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEvents(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Event.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventsPaged(pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventsPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventsPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventsPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Event.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getEvent(id, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Event.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    putEvent(id, includePropertyPaths, entity) {
        let url_ = this.baseUrl + "/Event/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPutEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPutEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPutEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Event.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patchEvent(id, includePropertyPaths, patch) {
        let url_ = this.baseUrl + "/Event/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatchEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatchEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatchEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Event.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteEvent(id) {
        let url_ = this.baseUrl + "/Event/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    postEvent(entity) {
        let url_ = this.baseUrl + "/Event";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPostEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPostEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPostEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = Event.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventLocations(includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Location/{includePropertyPaths}";
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventLocations(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventLocations(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventLocations(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventLocation.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventLocationsPaged(pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Location/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventLocationsPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventLocation.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventLocationsByEvent(eventId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{eventId}/Location/{includePropertyPaths}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventLocationsByEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventLocation.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventLocationsByEventPaged(eventId, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{eventId}/Location/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventLocationsByEventPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventLocation.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventLocationsByEventSchedule(eventScheduleId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Location/Schedule/{eventScheduleId}/{includePropertyPaths}";
        if (eventScheduleId === undefined || eventScheduleId === null)
            throw new Error("The parameter 'eventScheduleId' must be defined.");
        url_ = url_.replace("{eventScheduleId}", encodeURIComponent("" + eventScheduleId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventSchedule(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventSchedule(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventLocationsByEventSchedule(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventLocation.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventLocationsByEventSchedulePaged(eventScheduleId, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Location/Schedule/{eventScheduleId}/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (eventScheduleId === undefined || eventScheduleId === null)
            throw new Error("The parameter 'eventScheduleId' must be defined.");
        url_ = url_.replace("{eventScheduleId}", encodeURIComponent("" + eventScheduleId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventSchedulePaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventSchedulePaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventLocationsByEventSchedulePaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventLocation.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getEventLocation(id, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Location/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetEventLocation(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetEventLocation(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetEventLocation(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventLocation.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    putEventLocation(id, includePropertyPaths, entity) {
        let url_ = this.baseUrl + "/Event/Location/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPutEventLocation(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPutEventLocation(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPutEventLocation(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventLocation.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patchEventLocation(id, includePropertyPaths, patch) {
        let url_ = this.baseUrl + "/Event/Location/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatchEventLocation(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatchEventLocation(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatchEventLocation(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventLocation.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteEventLocation(id) {
        let url_ = this.baseUrl + "/Event/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteEventLocation(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteEventLocation(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteEventLocation(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    postEventLocation(entity) {
        let url_ = this.baseUrl + "/Event/Location";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPostEventLocation(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPostEventLocation(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPostEventLocation(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = EventLocation.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventSchedules(includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Schedule/{includePropertyPaths}";
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedules(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedules(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventSchedules(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventSchedule.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventSchedulesPaged(pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Schedule/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventSchedulesPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventSchedule.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventSchedulesByEvent(eventId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{eventId}/Schedule/{includePropertyPaths}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventSchedulesByEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventSchedule.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventSchedulesByEventPaged(eventId, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{eventId}/Schedule/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventSchedulesByEventPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventSchedule.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventSchedulesByEventLocation(eventLocationId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Schedule/Location/{eventLocationId}/{includePropertyPaths}";
        if (eventLocationId === undefined || eventLocationId === null)
            throw new Error("The parameter 'eventLocationId' must be defined.");
        url_ = url_.replace("{eventLocationId}", encodeURIComponent("" + eventLocationId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventLocation(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventLocation(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventSchedulesByEventLocation(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventSchedule.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventSchedulesByEventLocationPaged(eventLocationId, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Schedule/Location/{eventLocationId}/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (eventLocationId === undefined || eventLocationId === null)
            throw new Error("The parameter 'eventLocationId' must be defined.");
        url_ = url_.replace("{eventLocationId}", encodeURIComponent("" + eventLocationId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventLocationPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventLocationPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventSchedulesByEventLocationPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventSchedule.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getEventSchedule(id, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Schedule/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetEventSchedule(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetEventSchedule(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetEventSchedule(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventSchedule.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    putEventSchedule(id, includePropertyPaths, entity) {
        let url_ = this.baseUrl + "/Event/Schedule/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPutEventSchedule(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPutEventSchedule(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPutEventSchedule(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventSchedule.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patchEventSchedule(id, includePropertyPaths, patch) {
        let url_ = this.baseUrl + "/Event/Schedule/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatchEventSchedule(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatchEventSchedule(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatchEventSchedule(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventSchedule.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteEventSchedule(id) {
        let url_ = this.baseUrl + "/Event/Schedule/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteEventSchedule(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteEventSchedule(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteEventSchedule(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    postEventSchedule(entity) {
        let url_ = this.baseUrl + "/Event/Schedule";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPostEventSchedule(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPostEventSchedule(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPostEventSchedule(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = EventSchedule.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventOccurrences(includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Occurrence/{includePropertyPaths}";
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrences(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrences(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventOccurrences(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventOccurance.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventOccurrencesPaged(pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Occurrence/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventOccurrencesPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventOccurance.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventOccurrencesByEvent(eventId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{eventId}/Occurrence/{includePropertyPaths}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventOccurrencesByEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventOccurance.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventOccurrencesByEventPaged(eventId, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{eventId}/Occurrence/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventOccurrencesByEventPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventOccurance.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventOccurrencesByEventLocation(eventLocationId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Occurrence/Location/{eventLocationid}/{includePropertyPaths}";
        if (eventLocationId === undefined || eventLocationId === null)
            throw new Error("The parameter 'eventLocationId' must be defined.");
        url_ = url_.replace("{eventLocationId}", encodeURIComponent("" + eventLocationId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventLocation(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventLocation(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventOccurrencesByEventLocation(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventOccurance.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventOccurrencesByEventLocationPaged(eventLocationId, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Occurrence/Location/{eventLocationid}/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (eventLocationId === undefined || eventLocationId === null)
            throw new Error("The parameter 'eventLocationId' must be defined.");
        url_ = url_.replace("{eventLocationId}", encodeURIComponent("" + eventLocationId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventLocationPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventLocationPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventOccurrencesByEventLocationPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventSchedule.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventOccurrencesByEventSchedule(eventScheduleId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Occurrence/Schedule/{eventScheduleid}/{includePropertyPaths}";
        if (eventScheduleId === undefined || eventScheduleId === null)
            throw new Error("The parameter 'eventScheduleId' must be defined.");
        url_ = url_.replace("{eventScheduleId}", encodeURIComponent("" + eventScheduleId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventSchedule(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventSchedule(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventOccurrencesByEventSchedule(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventOccurance.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventOccurrencesByEventSchedulePaged(eventScheduleid, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Occurrence/Schedule/{eventScheduleid}/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (eventScheduleid === undefined || eventScheduleid === null)
            throw new Error("The parameter 'eventScheduleid' must be defined.");
        url_ = url_.replace("{eventScheduleid}", encodeURIComponent("" + eventScheduleid));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventSchedulePaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventSchedulePaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventOccurrencesByEventSchedulePaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventSchedule.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getEventOccurrence(id, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Occurrence/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetEventOccurrence(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetEventOccurrence(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetEventOccurrence(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventOccurance.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    putEventOccurrence(id, includePropertyPaths, entity) {
        let url_ = this.baseUrl + "/Event/Occurrence/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPutEventOccurrence(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPutEventOccurrence(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPutEventOccurrence(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventOccurance.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patchEventOccurrence(id, includePropertyPaths, patch) {
        let url_ = this.baseUrl + "/Event/Occurrence/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatchEventOccurrence(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatchEventOccurrence(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatchEventOccurrence(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventOccurance.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteEventOccurrence(id) {
        let url_ = this.baseUrl + "/Event/Occurrence/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteEventOccurrence(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteEventOccurrence(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteEventOccurrence(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    postEventOccurrence(entity) {
        let url_ = this.baseUrl + "/Event/Occurrence";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPostEventOccurrence(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPostEventOccurrence(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPostEventOccurrence(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = EventOccurance.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventServices(includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Service/{includePropertyPaths}";
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventServices(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventServices(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventServices(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventService.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventServicesPaged(pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Service/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventServicesPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventService.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventServicesByEvent(eventId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{eventId}/Service/{includePropertyPaths}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByEvent(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByEvent(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventServicesByEvent(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventService.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventServicesByEventPaged(eventId, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/{eventId}/Service/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByEventPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByEventPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventServicesByEventPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventService.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventServicesByService(serviceId, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Service/Service/{serviceId}/{includePropertyPaths}";
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByService(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByService(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventServicesByService(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventService.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllEventServicesByServicePaged(serviceId, pageNumber, pageSize, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Service/Service/{serviceId}/{pageNumber}/{pageSize}/{includePropertyPaths}";
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByServicePaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByServicePaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllEventServicesByServicePaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(EventService.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getEventService(id, includePropertyPaths) {
        let url_ = this.baseUrl + "/Event/Service/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetEventService(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetEventService(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetEventService(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventService.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    putEventService(id, includePropertyPaths, entity) {
        let url_ = this.baseUrl + "/Event/Service/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPutEventService(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPutEventService(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPutEventService(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventService.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patchEventService(id, includePropertyPaths, patch) {
        let url_ = this.baseUrl + "/Event/Service/{id}/{includePropertyPaths}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePropertyPaths === undefined || includePropertyPaths === null)
            throw new Error("The parameter 'includePropertyPaths' must be defined.");
        url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatchEventService(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatchEventService(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatchEventService(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EventService.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteEventService(id) {
        let url_ = this.baseUrl + "/Event/Service/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteEventService(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteEventService(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteEventService(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    postEventService(entity) {
        let url_ = this.baseUrl + "/Event/Service";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPostEventService(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPostEventService(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPostEventService(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = EventService.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
};
EventEndpointService = __decorate([
    Injectable(),
    __param(0, Inject(ConfigurationService)), __param(1, Inject(AuthEndpointService)), __param(2, Inject(HttpClient)), __param(3, Optional()), __param(3, Inject(API_BASE_URL))
], EventEndpointService);
export { EventEndpointService };
let ExtendedLogEndpointService = class ExtendedLogEndpointService extends BaseEndpointService {
    constructor(configService, authService, http, baseUrl) {
        super(configService, authService);
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
    }
    getAll() {
        let url_ = this.baseUrl + "/ExtendedLog";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAll(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExtendedLogViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteAll() {
        let url_ = this.baseUrl + "/ExtendedLog";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteAll(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteAll(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteAll(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    post(extendedLogVM) {
        let url_ = this.baseUrl + "/ExtendedLog";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(extendedLogVM);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPost(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPost(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPost(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = ExtendedLogViewModel.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllPaged(pageNumber, pageSize) {
        let url_ = this.baseUrl + "/ExtendedLog/{pageNumber}/{pageSize}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExtendedLogViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getByLevel(level) {
        let url_ = this.baseUrl + "/ExtendedLog/level/{level}";
        if (level === undefined || level === null)
            throw new Error("The parameter 'level' must be defined.");
        url_ = url_.replace("{level}", encodeURIComponent("" + level));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetByLevel(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetByLevel(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetByLevel(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExtendedLogViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getByLevelPaged(level, pageNumber, pageSize) {
        let url_ = this.baseUrl + "/ExtendedLog/level/{level}/{pageNumber}/{pageSize}";
        if (level === undefined || level === null)
            throw new Error("The parameter 'level' must be defined.");
        url_ = url_.replace("{level}", encodeURIComponent("" + level));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetByLevelPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetByLevelPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetByLevelPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExtendedLogViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    get(id) {
        let url_ = this.baseUrl + "/ExtendedLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGet(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ExtendedLogViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    delete(id) {
        let url_ = this.baseUrl + "/ExtendedLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDelete(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ExtendedLogViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    put(id, extendedLogVM) {
        let url_ = this.baseUrl + "/ExtendedLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(extendedLogVM);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPut(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPut(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPut(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patch(id, patch) {
        let url_ = this.baseUrl + "/ExtendedLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatch(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatch(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatch(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
};
ExtendedLogEndpointService = __decorate([
    Injectable(),
    __param(0, Inject(ConfigurationService)), __param(1, Inject(AuthEndpointService)), __param(2, Inject(HttpClient)), __param(3, Optional()), __param(3, Inject(API_BASE_URL))
], ExtendedLogEndpointService);
export { ExtendedLogEndpointService };
let ExtendedLogControllerNewEndpointService = class ExtendedLogControllerNewEndpointService extends BaseEndpointService {
    constructor(configService, authService, http, baseUrl) {
        super(configService, authService);
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
    }
    getAllExtendedLogs() {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllExtendedLogs(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllExtendedLogs(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllExtendedLogs(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExtendedLog.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteAllExtendedLogs() {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteAllExtendedLogs(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteAllExtendedLogs(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteAllExtendedLogs(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    postExtendedLog(entity) {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPostExtendedLog(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPostExtendedLog(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPostExtendedLog(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = ExtendedLog.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllExtendedLogsPaged(pageNumber, pageSize) {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew/{pageNumber}/{pageSize}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllExtendedLogsPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllExtendedLogsPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllExtendedLogsPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExtendedLog.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getExtendedLogsByLevel(level) {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew/level/{level}";
        if (level === undefined || level === null)
            throw new Error("The parameter 'level' must be defined.");
        url_ = url_.replace("{level}", encodeURIComponent("" + level));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetExtendedLogsByLevel(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetExtendedLogsByLevel(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetExtendedLogsByLevel(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExtendedLog.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getExtendedLogsByLevelPaged(level, pageNumber, pageSize) {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew/level/{level}/{pageNumber}/{pageSize}";
        if (level === undefined || level === null)
            throw new Error("The parameter 'level' must be defined.");
        url_ = url_.replace("{level}", encodeURIComponent("" + level));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetExtendedLogsByLevelPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetExtendedLogsByLevelPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetExtendedLogsByLevelPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExtendedLog.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getExtendedLog(id) {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetExtendedLog(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetExtendedLog(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetExtendedLog(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ExtendedLog.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteExtendedLog(id) {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteExtendedLog(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteExtendedLog(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteExtendedLog(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    putExtendedLog(id, entity) {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPutExtendedLog(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPutExtendedLog(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPutExtendedLog(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patchExtendedLog(id, patch) {
        let url_ = this.baseUrl + "/ExtendedLogControllerNew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatchExtendedLog(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatchExtendedLog(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatchExtendedLog(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
};
ExtendedLogControllerNewEndpointService = __decorate([
    Injectable(),
    __param(0, Inject(ConfigurationService)), __param(1, Inject(AuthEndpointService)), __param(2, Inject(HttpClient)), __param(3, Optional()), __param(3, Inject(API_BASE_URL))
], ExtendedLogControllerNewEndpointService);
export { ExtendedLogControllerNewEndpointService };
let NotificationEndpointService = class NotificationEndpointService extends BaseEndpointService {
    constructor(configService, authService, http, baseUrl) {
        super(configService, authService);
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
    }
    getAll() {
        let url_ = this.baseUrl + "/Notification";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAll(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(NotificationViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    post(notificationVM) {
        let url_ = this.baseUrl + "/Notification";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(notificationVM);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPost(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPost(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPost(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = NotificationViewModel.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllPaged(pageNumber, pageSize) {
        let url_ = this.baseUrl + "/Notification/{pageNumber}/{pageSize}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(NotificationViewModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    get(id) {
        let url_ = this.baseUrl + "/Notification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGet(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = NotificationViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    delete(id) {
        let url_ = this.baseUrl + "/Notification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDelete(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = NotificationViewModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    put(id, notificationVM) {
        let url_ = this.baseUrl + "/Notification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(notificationVM);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPut(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPut(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPut(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patch(id, patch) {
        let url_ = this.baseUrl + "/Notification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatch(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatch(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatch(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
};
NotificationEndpointService = __decorate([
    Injectable(),
    __param(0, Inject(ConfigurationService)), __param(1, Inject(AuthEndpointService)), __param(2, Inject(HttpClient)), __param(3, Optional()), __param(3, Inject(API_BASE_URL))
], NotificationEndpointService);
export { NotificationEndpointService };
let NotificationControllerNewEndpointService = class NotificationControllerNewEndpointService extends BaseEndpointService {
    constructor(configService, authService, http, baseUrl) {
        super(configService, authService);
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
    }
    getAllNotifications() {
        let url_ = this.baseUrl + "/NotificationControllerNew";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllNotifications(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllNotifications(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllNotifications(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Notification.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    postNotification(entity) {
        let url_ = this.baseUrl + "/NotificationControllerNew";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPostNotification(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPostNotification(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPostNotification(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = Notification.fromJS(resultData201);
                return _observableOf(result201);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getAllNotificationsPaged(pageNumber, pageSize) {
        let url_ = this.baseUrl + "/NotificationControllerNew/{pageNumber}/{pageSize}";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllNotificationsPaged(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllNotificationsPaged(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetAllNotificationsPaged(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Notification.fromJS(item));
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    getNotification(id) {
        let url_ = this.baseUrl + "/NotificationControllerNew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processGetNotification(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetNotification(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processGetNotification(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Notification.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    deleteNotification(id) {
        let url_ = this.baseUrl + "/NotificationControllerNew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteNotification(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteNotification(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processDeleteNotification(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    putNotification(id, entity) {
        let url_ = this.baseUrl + "/NotificationControllerNew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(entity);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPutNotification(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPutNotification(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPutNotification(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
    patchNotification(id, patch) {
        let url_ = this.baseUrl + "/NotificationControllerNew/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(patch);
        let options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_) => {
            return this.transformResult(url_, response_, (r) => this.processPatchNotification(r));
        })).pipe(_observableCatch((response_) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPatchNotification(r));
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    }
    processPatchNotification(response) {
        const status = response.status;
        const responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        let _headers = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf(null);
            }));
        }
        else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    }
};
NotificationControllerNewEndpointService = __decorate([
    Injectable(),
    __param(0, Inject(ConfigurationService)), __param(1, Inject(AuthEndpointService)), __param(2, Inject(HttpClient)), __param(3, Optional()), __param(3, Inject(API_BASE_URL))
], NotificationControllerNewEndpointService);
export { NotificationControllerNewEndpointService };
export class ApplicationViewModelBase {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.rowVersion = _data["rowVersion"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ApplicationViewModelBase' cannot be instantiated.");
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["rowVersion"] = this.rowVersion;
        return data;
    }
    clone() {
        throw new Error("The abstract class 'ApplicationViewModelBase' cannot be instantiated.");
    }
}
export class UserBaseViewModel extends ApplicationViewModelBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.jobTitle = _data["jobTitle"];
            this.phoneNumber = _data["phoneNumber"];
            this.configuration = _data["configuration"];
            this.isEnabled = _data["isEnabled"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UserBaseViewModel' cannot be instantiated.");
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["jobTitle"] = this.jobTitle;
        data["phoneNumber"] = this.phoneNumber;
        data["configuration"] = this.configuration;
        data["isEnabled"] = this.isEnabled;
        super.toJSON(data);
        return data;
    }
    clone() {
        throw new Error("The abstract class 'UserBaseViewModel' cannot be instantiated.");
    }
}
export class UserViewModel extends UserBaseViewModel {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.isLockedOut = _data["isLockedOut"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [];
                for (let item of _data["roles"])
                    this.roles.push(item);
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["isLockedOut"] = this.isLockedOut;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new UserViewModel();
        result.init(json);
        return result;
    }
}
export class ProblemDetails {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {};
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions[key] = _data["extensions"][key];
                }
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new ProblemDetails();
        result.init(json);
        return result;
    }
}
export class UserEditViewModel extends UserBaseViewModel {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.isLockedOut = _data["isLockedOut"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [];
                for (let item of _data["roles"])
                    this.roles.push(item);
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditViewModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["isLockedOut"] = this.isLockedOut;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new UserEditViewModel();
        result.init(json);
        return result;
    }
}
export class OperationBase {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.path = _data["path"];
            this.op = _data["op"];
            this.from = _data["from"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new OperationBase();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["op"] = this.op;
        data["from"] = this.from;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new OperationBase();
        result.init(json);
        return result;
    }
}
export class Operation extends OperationBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Operation();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new Operation();
        result.init(json);
        return result;
    }
}
export class RoleViewModel extends ApplicationViewModelBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.usersCount = _data["usersCount"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [];
                for (let item of _data["permissions"])
                    this.permissions.push(PermissionViewModel.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new RoleViewModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["usersCount"] = this.usersCount;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new RoleViewModel();
        result.init(json);
        return result;
    }
}
export class PermissionViewModel extends ApplicationViewModelBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
            this.groupName = _data["groupName"];
            this.description = _data["description"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionViewModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        data["groupName"] = this.groupName;
        data["description"] = this.description;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new PermissionViewModel();
        result.init(json);
        return result;
    }
}
export class EntityBase {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.rowVersion = _data["rowVersion"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EntityBase' cannot be instantiated.");
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["rowVersion"] = this.rowVersion;
        return data;
    }
    clone() {
        throw new Error("The abstract class 'EntityBase' cannot be instantiated.");
    }
}
export class Event extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [];
                for (let item of _data["locations"])
                    this.locations.push(EventLocation.fromJS(item));
            }
            if (Array.isArray(_data["schedules"])) {
                this.schedules = [];
                for (let item of _data["schedules"])
                    this.schedules.push(EventSchedule.fromJS(item));
            }
            if (Array.isArray(_data["occurances"])) {
                this.occurances = [];
                for (let item of _data["occurances"])
                    this.occurances.push(EventOccurance.fromJS(item));
            }
            if (Array.isArray(_data["services"])) {
                this.services = [];
                for (let item of _data["services"])
                    this.services.push(EventService.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Event();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.schedules)) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item.toJSON());
        }
        if (Array.isArray(this.occurances)) {
            data["occurances"] = [];
            for (let item of this.occurances)
                data["occurances"].push(item.toJSON());
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new Event();
        result.init(json);
        return result;
    }
}
export class EventLocation extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.eventId = _data["eventId"];
            this.event = _data["event"] ? Event.fromJS(_data["event"]) : undefined;
            if (Array.isArray(_data["schedules"])) {
                this.schedules = [];
                for (let item of _data["schedules"])
                    this.schedules.push(EventSchedule.fromJS(item));
            }
            if (Array.isArray(_data["occurances"])) {
                this.occurances = [];
                for (let item of _data["occurances"])
                    this.occurances.push(EventOccurance.fromJS(item));
            }
            this.name = _data["name"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new EventLocation();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["event"] = this.event ? this.event.toJSON() : undefined;
        if (Array.isArray(this.schedules)) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item.toJSON());
        }
        if (Array.isArray(this.occurances)) {
            data["occurances"] = [];
            for (let item of this.occurances)
                data["occurances"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new EventLocation();
        result.init(json);
        return result;
    }
}
export class EventSchedule extends EntityBase {
    constructor(data) {
        super(data);
        if (!data) {
            this.startTime = new TimeOfDay();
            this.endTime = new TimeOfDay();
            this.checkInStartTime = new TimeOfDay();
            this.checkInEndTime = new TimeOfDay();
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.eventId = _data["eventId"];
            this.event = _data["event"] ? Event.fromJS(_data["event"]) : undefined;
            this.eventLocationId = _data["eventLocationId"];
            this.location = _data["location"] ? EventLocation.fromJS(_data["location"]) : undefined;
            if (Array.isArray(_data["occurances"])) {
                this.occurances = [];
                for (let item of _data["occurances"])
                    this.occurances.push(EventOccurance.fromJS(item));
            }
            this.daysOfTheWeek = _data["daysOfTheWeek"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined;
            this.startTime = _data["startTime"] ? TimeOfDay.fromJS(_data["startTime"]) : new TimeOfDay();
            this.endTime = _data["endTime"] ? TimeOfDay.fromJS(_data["endTime"]) : new TimeOfDay();
            this.checkInStartTime = _data["checkInStartTime"] ? TimeOfDay.fromJS(_data["checkInStartTime"]) : new TimeOfDay();
            this.checkInEndTime = _data["checkInEndTime"] ? TimeOfDay.fromJS(_data["checkInEndTime"]) : new TimeOfDay();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new EventSchedule();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["event"] = this.event ? this.event.toJSON() : undefined;
        data["eventLocationId"] = this.eventLocationId;
        data["location"] = this.location ? this.location.toJSON() : undefined;
        if (Array.isArray(this.occurances)) {
            data["occurances"] = [];
            for (let item of this.occurances)
                data["occurances"].push(item.toJSON());
        }
        data["daysOfTheWeek"] = this.daysOfTheWeek;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined;
        data["startTime"] = this.startTime ? this.startTime.toJSON() : undefined;
        data["endTime"] = this.endTime ? this.endTime.toJSON() : undefined;
        data["checkInStartTime"] = this.checkInStartTime ? this.checkInStartTime.toJSON() : undefined;
        data["checkInEndTime"] = this.checkInEndTime ? this.checkInEndTime.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new EventSchedule();
        result.init(json);
        return result;
    }
}
export class EventOccurance extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.eventId = _data["eventId"];
            this.event = _data["event"] ? Event.fromJS(_data["event"]) : undefined;
            this.eventLocationId = _data["eventLocationId"];
            this.location = _data["location"] ? EventLocation.fromJS(_data["location"]) : undefined;
            this.eventScheduleId = _data["eventScheduleId"];
            this.schedule = _data["schedule"] ? EventSchedule.fromJS(_data["schedule"]) : undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined;
            this.lead = _data["lead"];
            if (Array.isArray(_data["demerits"])) {
                this.demerits = [];
                for (let item of _data["demerits"])
                    this.demerits.push(Demerit.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new EventOccurance();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["event"] = this.event ? this.event.toJSON() : undefined;
        data["eventLocationId"] = this.eventLocationId;
        data["location"] = this.location ? this.location.toJSON() : undefined;
        data["eventScheduleId"] = this.eventScheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : undefined;
        data["date"] = this.date ? this.date.toISOString() : undefined;
        data["lead"] = this.lead;
        if (Array.isArray(this.demerits)) {
            data["demerits"] = [];
            for (let item of this.demerits)
                data["demerits"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new EventOccurance();
        result.init(json);
        return result;
    }
}
export class Demerit extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.guestId = _data["guestId"];
            this.guest = _data["guest"] ? Guest.fromJS(_data["guest"]) : undefined;
            this.eventOccuranceId = _data["eventOccuranceId"];
            this.eventOccurance = _data["eventOccurance"] ? EventOccurance.fromJS(_data["eventOccurance"]) : undefined;
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : undefined;
            this.description = _data["description"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Demerit();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["guestId"] = this.guestId;
        data["guest"] = this.guest ? this.guest.toJSON() : undefined;
        data["eventOccuranceId"] = this.eventOccuranceId;
        data["eventOccurance"] = this.eventOccurance ? this.eventOccurance.toJSON() : undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : undefined;
        data["description"] = this.description;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new Demerit();
        result.init(json);
        return result;
    }
}
export class Guest extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["demerits"])) {
                this.demerits = [];
                for (let item of _data["demerits"])
                    this.demerits.push(Demerit.fromJS(item));
            }
            if (Array.isArray(_data["eventOccurances"])) {
                this.eventOccurances = [];
                for (let item of _data["eventOccurances"])
                    this.eventOccurances.push(GuestEventOccurance.fromJS(item));
            }
            this.uniqueId = _data["uniqueId"];
            this.prefix = _data["prefix"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.suffix = _data["suffix"];
            this.sex = _data["sex"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.establishedGuest = _data["establishedGuest"];
            this.image = _data["image"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Guest();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.demerits)) {
            data["demerits"] = [];
            for (let item of this.demerits)
                data["demerits"].push(item.toJSON());
        }
        if (Array.isArray(this.eventOccurances)) {
            data["eventOccurances"] = [];
            for (let item of this.eventOccurances)
                data["eventOccurances"].push(item.toJSON());
        }
        data["uniqueId"] = this.uniqueId;
        data["prefix"] = this.prefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["suffix"] = this.suffix;
        data["sex"] = this.sex;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["establishedGuest"] = this.establishedGuest;
        data["image"] = this.image;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new Guest();
        result.init(json);
        return result;
    }
}
export class GuestEventOccurance extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.guestId = _data["guestId"];
            this.guest = _data["guest"] ? Guest.fromJS(_data["guest"]) : undefined;
            this.eventOccuranceId = _data["eventOccuranceId"];
            this.eventOccurance = _data["eventOccurance"] ? EventOccurance.fromJS(_data["eventOccurance"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new GuestEventOccurance();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["guestId"] = this.guestId;
        data["guest"] = this.guest ? this.guest.toJSON() : undefined;
        data["eventOccuranceId"] = this.eventOccuranceId;
        data["eventOccurance"] = this.eventOccurance ? this.eventOccurance.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new GuestEventOccurance();
        result.init(json);
        return result;
    }
}
/** 0 = Male 1 = Female */
export var Sexes;
(function (Sexes) {
    Sexes[Sexes["Male"] = 0] = "Male";
    Sexes[Sexes["Female"] = 1] = "Female";
})(Sexes || (Sexes = {}));
/** 0 = Sunday 1 = Monday 2 = Tuesday 3 = Wednesday 4 = Thursday 5 = Friday 6 = Saturaday */
export var Days;
(function (Days) {
    Days[Days["Sunday"] = 0] = "Sunday";
    Days[Days["Monday"] = 1] = "Monday";
    Days[Days["Tuesday"] = 2] = "Tuesday";
    Days[Days["Wednesday"] = 3] = "Wednesday";
    Days[Days["Thursday"] = 4] = "Thursday";
    Days[Days["Friday"] = 5] = "Friday";
    Days[Days["Saturaday"] = 6] = "Saturaday";
})(Days || (Days = {}));
export class TimeOfDay {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.hhmmss = _data["hhmmss"];
            this.hour = _data["hour"];
            this.minute = _data["minute"];
            this.second = _data["second"];
            this.totalDays = _data["totalDays"];
            this.totalHours = _data["totalHours"];
            this.totalMinutes = _data["totalMinutes"];
            this.totalSeconds = _data["totalSeconds"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new TimeOfDay();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["hhmmss"] = this.hhmmss;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["second"] = this.second;
        data["totalDays"] = this.totalDays;
        data["totalHours"] = this.totalHours;
        data["totalMinutes"] = this.totalMinutes;
        data["totalSeconds"] = this.totalSeconds;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new TimeOfDay();
        result.init(json);
        return result;
    }
}
export class EventService extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.eventId = _data["eventId"];
            this.event = _data["event"] ? Event.fromJS(_data["event"]) : undefined;
            this.serviceId = _data["serviceId"];
            this.service = _data["service"] ? Service.fromJS(_data["service"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new EventService();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["event"] = this.event ? this.event.toJSON() : undefined;
        data["serviceId"] = this.serviceId;
        data["service"] = this.service ? this.service.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new EventService();
        result.init(json);
        return result;
    }
}
export class Service extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.serviceType = _data["serviceType"];
            if (Array.isArray(_data["eventServices"])) {
                this.eventServices = [];
                for (let item of _data["eventServices"])
                    this.eventServices.push(EventService.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Service();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["serviceType"] = this.serviceType;
        if (Array.isArray(this.eventServices)) {
            data["eventServices"] = [];
            for (let item of this.eventServices)
                data["eventServices"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new Service();
        result.init(json);
        return result;
    }
}
/** 0 = Normal 1 = Queue 2 = Time */
export var ServiceTypes;
(function (ServiceTypes) {
    ServiceTypes[ServiceTypes["Normal"] = 0] = "Normal";
    ServiceTypes[ServiceTypes["Queue"] = 1] = "Queue";
    ServiceTypes[ServiceTypes["Time"] = 2] = "Time";
})(ServiceTypes || (ServiceTypes = {}));
export class ExtendedLogViewModel extends ApplicationViewModelBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.browser = _data["browser"];
            this.host = _data["host"];
            this.path = _data["path"];
            this.user = _data["user"];
            this.eventId = _data["eventId"];
            this.id = _data["id"];
            this.level = _data["level"];
            this.levelDescription = _data["levelDescription"];
            this.message = _data["message"];
            this.name = _data["name"];
            this.method = _data["method"];
            this.statusCode = _data["statusCode"];
            this.serverVariables = _data["serverVariables"];
            this.cookies = _data["cookies"];
            this.formVariables = _data["formVariables"];
            this.queryString = _data["queryString"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedLogViewModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["browser"] = this.browser;
        data["host"] = this.host;
        data["path"] = this.path;
        data["user"] = this.user;
        data["eventId"] = this.eventId;
        data["id"] = this.id;
        data["level"] = this.level;
        data["levelDescription"] = this.levelDescription;
        data["message"] = this.message;
        data["name"] = this.name;
        data["method"] = this.method;
        data["statusCode"] = this.statusCode;
        data["serverVariables"] = this.serverVariables;
        data["cookies"] = this.cookies;
        data["formVariables"] = this.formVariables;
        data["queryString"] = this.queryString;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : undefined;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new ExtendedLogViewModel();
        result.init(json);
        return result;
    }
}
export class LogOfString {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.id = _data["id"];
            this.level = _data["level"];
            this.message = _data["message"];
            this.name = _data["name"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new LogOfString();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["id"] = this.id;
        data["level"] = this.level;
        data["message"] = this.message;
        data["name"] = this.name;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : undefined;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new LogOfString();
        result.init(json);
        return result;
    }
}
export class ExtendedLog extends LogOfString {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.levelDescription = _data["levelDescription"];
            this.browser = _data["browser"];
            this.host = _data["host"];
            this.path = _data["path"];
            this.user = _data["user"];
            this.method = _data["method"];
            this.statusCode = _data["statusCode"];
            this.serverVariables = _data["serverVariables"];
            this.cookies = _data["cookies"];
            this.formVariables = _data["formVariables"];
            this.queryString = _data["queryString"];
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.rowVersion = _data["rowVersion"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedLog();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["levelDescription"] = this.levelDescription;
        data["browser"] = this.browser;
        data["host"] = this.host;
        data["path"] = this.path;
        data["user"] = this.user;
        data["method"] = this.method;
        data["statusCode"] = this.statusCode;
        data["serverVariables"] = this.serverVariables;
        data["cookies"] = this.cookies;
        data["formVariables"] = this.formVariables;
        data["queryString"] = this.queryString;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["rowVersion"] = this.rowVersion;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new ExtendedLog();
        result.init(json);
        return result;
    }
}
export class NotificationViewModel extends ApplicationViewModelBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.body = _data["body"];
            this.isRead = _data["isRead"];
            this.isPinned = _data["isPinned"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationViewModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["body"] = this.body;
        data["isRead"] = this.isRead;
        data["isPinned"] = this.isPinned;
        data["date"] = this.date ? this.date.toISOString() : undefined;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new NotificationViewModel();
        result.init(json);
        return result;
    }
}
export class Notification extends EntityBase {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.header = _data["header"];
            this.body = _data["body"];
            this.isRead = _data["isRead"];
            this.isPinned = _data["isPinned"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["body"] = this.body;
        data["isRead"] = this.isRead;
        data["isPinned"] = this.isPinned;
        data["date"] = this.date ? this.date.toISOString() : undefined;
        super.toJSON(data);
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new Notification();
        result.init(json);
        return result;
    }
}
export class ServiceException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isServiceException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isServiceException(obj) {
        return obj.isServiceException === true;
    }
}
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ServiceException(message, status, response, headers, null));
}
function blobToText(blob) {
    return new Observable((observer) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        }
        else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next(event.target.result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
export class PermissionValues {
}
PermissionValues.ViewLogs = 'logs.view';
PermissionValues.ManageLogs = 'logs.manage';
PermissionValues.ViewEvents = 'events.view';
PermissionValues.ManageEvents = 'events.manage';
PermissionValues.ExecuteEvents = 'events.execute';
PermissionValues.ViewUsers = 'users.view';
PermissionValues.ManageUsers = 'users.manage';
PermissionValues.ViewRoles = 'roles.view';
PermissionValues.ManageRoles = 'roles.manage';
PermissionValues.AssignRoles = 'roles.assign';
//# sourceMappingURL=endpoint.services.js.map